generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "mysql"
  url      = env("DATABASE_URL")
}

model User {
  idUsers      String                @id @default(uuid()) @db.Char(36)
  username     String                @db.VarChar(30)
  email        String                @unique @db.VarChar(50)
  profileImg   String?               @db.VarChar(255)
  userPass     String                @db.VarChar(255)
  userDesc     String?               @db.VarChar(255)
  socialLinks  UserSocialLink[]
  preferencesMusic  MusicPreference[]
  preferencesArtist ArtistPreference[]
  matches1     Match[]               @relation("user1Matches")
  matches2     Match[]               @relation("user2Matches")
  recentAlbums UserAlbum[]
  playlists    UserPlaylist[]
}

model UserSocialLink {
  idLink       String @id @default(uuid()) @db.Char(36)
  platformName String @db.VarChar(50)
  profileLink  String @db.VarChar(255)
  userID       String
  user         User   @relation(fields: [userID], references: [idUsers], onDelete: Cascade)
}

model MusicPreference {
  idMusic      String                @id @default(uuid()) @db.Char(36)
  songName     String                @db.VarChar(100)
  artistId     String
  artistN      ArtistPreference @relation(fields: [artistId], references: [idArtist]) 
  userRef      User @relation(fields: [idUser], references: [idUsers], onDelete: Cascade)
  idUser       String
  MatchRef MatchDetail[]
}

model ArtistPreference {
  idArtist     String                @id @default(uuid()) @db.Char(36)
  artistName   String                @db.VarChar(100)
  idUser       String
  userRef      User @relation(fields: [idUser], references: [idUsers], onDelete: Cascade)
  musicR MusicPreference[]
  albumR Album[]
  MatchRef MatchDetail[]
}

model Album {
  idAlbum           String @id @default(uuid()) @db.Char(36)
  name         String
  artistId      String
  artistN      ArtistPreference @relation(fields: [artistId], references: [idArtist]) 
  userAlb      UserAlbum[]
}
model UserAlbum {
  id      String @id @default(uuid()) @db.Char(36)
  userID  String
  albumID String
  user    User   @relation(fields: [userID], references: [idUsers], onDelete: Cascade)
  album   Album  @relation(fields: [albumID], references: [idAlbum], onDelete: Cascade)
  @@unique([userID, albumID])
}

model Playlist {
  idPlaylist    String         @id @default(uuid()) @db.Char(36)
  name          String         @db.VarChar(100)
  coverUrl      String?        @db.VarChar(255)
  ownerID       String?
  userPlaylists UserPlaylist[]
}

model UserPlaylist {
  id         String   @id @default(uuid()) @db.Char(36)
  userID     String
  playlistID String
  user       User     @relation(fields: [userID], references: [idUsers], onDelete: Cascade)
  playlist   Playlist @relation(fields: [playlistID], references: [idPlaylist], onDelete: Cascade)

  @@unique([userID, playlistID])
}

model Match {
  idMatch   String        @id @default(uuid()) @db.Char(36)
  user1ID   String
  user2ID   String
  matchDate DateTime      @default(now())
  user1     User          @relation("user1Matches", fields: [user1ID], references: [idUsers], onDelete: Cascade)
  user2     User          @relation("user2Matches", fields: [user2ID], references: [idUsers], onDelete: Cascade)
  details   MatchDetail[]
}

model MatchDetail {
  idDetail String  @id @default(uuid()) @db.Char(36)
  idMatch  String
  musicId  String?
  artistId String?
  match    Match   @relation(fields: [idMatch], references: [idMatch], onDelete: Cascade)
  music    MusicPreference?  @relation(fields: [musicId], references: [idMusic], onDelete: Cascade)
  artist   ArtistPreference? @relation(fields: [artistId], references: [idArtist], onDelete: Cascade)

  @@unique([idMatch, musicId, artistId])
}
